[
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.abstract_class_instantiation",
		"message": "Cannot instantiate the abstract type *type-name*",
		"cause": "This error is generated when you try to create an instance of an abstract class",
		"solution": "Replace *type-name* by the name of a concrete class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.abstract_method_invocation",
		"message": "Cannot directly invoke the abstract method *func-prototype* of the type *name*",
		"cause": "The function with the given *func-prototype* is defined as non-abstract in the current type, and it is defined as `abstract` into the super-type. You try to call the super-type's method by using `super.function`. But, the super-type's function is `abstract`. Consequently, it cannot be invoked",
		"solution": "Remove the call to the super-type function",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.ambiguous_feature_call",
		"message": "Ambiguous *feature-call*. The *feature-type* *feature-1* and *feature-2* both match",
		"cause": "You are calling a feature (method, field, etc.). But, the target feature is ambiguous. Multiple candidates were found within the scope of your call. SARL compiler cannot choose the concrete feature to be called. In order to help you, the SARL compiler provides to you the list of candidates",
		"solution": "Rewrite your code in order to remove the ambiguity",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.ambiguous_feature_call",
		"message": "Ambiguous *feature-call*. The *feature-type* *list-of-features* and *feature-2* all match",
		"cause": "You are calling a feature (method, field, etc.). But, the target feature is ambiguous. Multiple candidates were found within the scope of your call. SARL compiler cannot choose the concrete feature to be called. In order to help you, the SARL compiler provides to you the list of candidates",
		"solution": "Rewrite your code in order to remove the ambiguity",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_illegal_value",
		"message": "The value for an annotation attribute must be a constant expression",
		"cause": "It is forbidden to give a value to an annotation that is not a constant expression, i.e., an expression without variable reference, function calls, etc",
		"solution": "Rewrite the value expression to have only constant features inside",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_attribute_value",
		"message": "The attribute value is undefined for the annotation type *name*",
		"cause": "You are trying to provide a value to an annotation, but the field `value` is not defined into the annotation.\nThis error may occur when you write `@MyAnnotion(\"value\")` with a definition of `MyAnnotation` without a field named `value`. In this example, assuming that the declared field is named `myfield`, the correct notation is `@MyAnnotation(myfield = \"value\")`.\nAs for other languages as Java, SARL assumes that if the name of the attribute is not provided, the default attribute name is `value`",
		"solution": "Add the name of the attribute before the value",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.anonymous_class_missing_members",
		"message": "The anonymous subclass of *type-name* does not implement *list-of-functions*",
		"cause": "Because anonymous class cannot be abstract, all the abstract functions that are inherited must be implemented into the anonymous class",
		"solution": "Implement the missed functions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.anonymous_class_static_field",
		"message": "A static field of an anonymous class must be final",
		"cause": "Because an anonymous class is a class, we can declare `static` fields for sharing data between the difference instances of the anonymous class (that is the usual usage of static fields for regular classes). However, because an anonymous class is attached to its enclosing context, any side-effect applied by the change of the static field's value must be avoided. That's why a static field in an anonymous class must be unmodifiable, i.e., defined with `val` or marked with the `final` modifier", 
		"solution": "Replace `var` keyword by `val`; or add the `static` modifier to the field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.anonymous_class_static_method",
		"message": "A method of an anonymous class cannot be static",
		"cause": "Because an anonymous class is not a named type, we cannot refer to its functions with a static notation (that is the name of the type, followed by the name of the function). Consequently, it is forbidden to define a static function into an anonymous class",
		"solution": "Remove `static` modifier from the function prototype",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_final",
		"message": "Assignment to final variable",
		"cause": "You try to assign a value to a variable that is declared as final, e.g., `val myvar` or `final var myvar`. Since the variable is declared as final, its value cannot be changed",
		"solution": "Remove the final modifier on the variable; or assign to another not-final variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_final",
		"message": "Assignment to final parameter",
		"cause": "You try to assign a value to a parameter. Parameters are always considered as final from the SARL specification. Since the parameter is declared as final, its value cannot be changed",
		"solution": "Assign to another not-final variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_final",
		"message": "Assignment to final field",
		"cause": "You try to assign a value to a field that is declared as final, e.g., `val myvar` or `final var myvar`. Since the field is declared as final, its value cannot be changed",
		"solution": "Remove the final modifier on the field; or assign to another not-final field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.assignment_to_no_variable",
		"message": "The left-hand side of an assignment must be a variable",
		"cause": "According to the definition of the assignment operator, the left operand must always be a variable or a field that is not declared as final. When this error message is generated, it means that the left operand is neither a variable nor a field.\nPlease not that the use of the assignment operator may be considered as a call to a \"setter\" function. In this case, this error message is not generated",
		"solution": "Replace the left operand with an appropriate variable or field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.circular_constructor_invocation",
		"message": "Recursive constructor invocation",
		"cause": "You have defined several constructors into your type that are calling other constructors in the type. The sequence of constructor's calls contains a loop; that is forbidden. An example of failing code is:\n&p.lt;code&p.gt;class X {&p.lt;br&p.gt;&nbsp;&nbsp;new (x : int) {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;this('c')&p.lt;br&p.gt;&nbsp;&nbsp;}&p.lt;br&p.gt;&nbsp;&nbsp;new (x : char) {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;this(1)&p.lt;br&p.gt;&nbsp;&nbsp;}&p.lt;br&p.gt;}&p.lt;/code&p.gt;",
		"solution": "Rewrite your code to avoid cyclic calls to the constructors",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.class_expected",
		"message": "Superclass must be a class",
		"cause": "According to the syntax of SARL, a class extends another class. This error message indicates to you that the type after `extends` is not a class",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.class_expected",
		"message": "Invalid supertype. Expecting a class",
		"cause": "According to the syntax of SARL, a type (class, agent, skill, etc.) extends another type. This error message indicates to you that the type after `extends` is not a type implemented with a Java class, when it is expected to have one",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.class_must_be_defined_abstract",
		"message": "The class *type-name* must be defined abstract because it does not implement *list-of-functions*",
		"cause": "You have defined abstract functions into *type-name*, or abstract functions are inherited without beeing implemented. In this case, the *type-name* must also be defined as `abstract` because abstract functions can only be defined into an abstract type",
		"solution": "Add `abstract` modifier to *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.conflicting_default_methods",
		"message": "The type *type-name* inherits multiple implementations of the method *func-prototype* from *first-type* and *second-type*",
		"cause": "This error message is generated when the current type with name *type-name* inherited a block of code for the function with the signature *func-prototype*, either from the super-type named *first-type* and the one named *second-type*. It is impossible for the SARL compiler to determine which one of the two blocks of code to be associated to *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.conflicting_default_methods",
		"message": "The non-abstract method *first-prototype* inherited from *first-type* conflicts with the method *second-prototype* inherited from *second-type*",
		"cause": "This error message is generated when the current type inherited from two functions from types *first-type* and *second-type*, and there is a conflict between the signatures of these functions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.constant_condition",
		"message": "Constant condition is always *boolean-constant*",
		"cause": "The loop, if-then and switch statements may have a boolean condition that is evalued to `true` or `false`. In this case, the statement itself is superfluous. For example, in the case of a while-loop, if the condition is alwaus `true`, the loop will never exit. This issue message notifies you that a potentiel problem is detected because of the evaluation of an expression to `true` or `false`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.cyclic_inheritance",
		"message": "The inheritance hierarchy of *type* contains cycles",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, cyclic into the inheritance hierarchy is totally forbidden",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The method *func-prototype* from the type *container-name* is deprecated",
		"cause": "The method that you are calling is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The field *name* is deprecated",
		"cause": "The field that you are accessor is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The enum literal *name* is deprecated",
		"cause": "The enum literal that you are using is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The constructor *name* is deprecated",
		"cause": "The constructor that you are calling is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.deprecated_member_reference",
		"message": "The type *name* is deprecated",
		"cause": "The type that you are referencing is marked as deprecated directly, or one of its enclosing types is marked as deprecated",
		"solution": "Read the deprecation comment and update your code accordingly",
		"level": "d/org.eclipse.jdt.core.compiler.problem.deprecation/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.discouraged_reference",
		"message": "Discouraged feature call: *feature*. You should use the dedicated language keyword, or an agent's capacity in place of this feature call",
		"cause": "This error is generated when a discouraged feature call is detected. The features that outside the best practices are: `System::err`, `System::out`, `System::setErr`, `System::setOut`, `System::console`, `System::inheritedChannel`, `System::exit` (when called from an object-oriented type), with a named starting with \"InputOutput\" or \"Thread\". these different features are considered to be too low level to be used into a agent-oriented program",
		"solution": "Remove the call",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_case",
		"message": "Duplicate case",
		"cause": "Into a `switch` statement, you have specified multiple times the same `case`, i.e., with the same case expression. Then, it is impossible to branch to a single `case` from the expression evaluated by the `switch` statement. This ambiguous branching is forbidden",
		"solution": "Remove one of the cases; or merge the two cases into a single case",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_field",
		"message": "Duplicate field *name*",
		"cause": "It is forbidden to define multiple fields with the same name into the same type. This error message is generated when two fields have the given *name*",
		"solution": "Rename one of the two fields",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_field",
		"message": "Duplicate extension with same type",
		"cause": "[Extension on fields](./general/Extension.md) is supported by SARL syntax. This error message is generated when two extensions have the same name. It is forbidden because they generate two hidden fields with the same name",
		"solution": "Rename one of the extensions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_interface",
		"message": "Duplicate interface",
		"cause": "This warning message is generated when a type is implemented the same interface multiple times`",
		"solution": "Remove the extra declarations of the implemented interface",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_method",
		"message": "Duplicate method *func-prototype* in type *type-name*",
		"cause": "It is forbidden to define two times a function with the same prototype/erasure. This error message is generated when two functions has the same prototype inside the current type declaration",
		"solution": "Rename one of the functions; or change the erasure of one of them",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_method",
		"message": "The method *func-prototype* has the same erasure *func-erasure* as another method in type *type-name*",
		"cause": "It is forbidden to define two times a function with the same prototype/erasure. This error message is generated when two functions has the same prototype inside the current type declaration",
		"solution": "Rename one of the functions; or change the erasure of one of them",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_method",
		"message": "The instance method *func-prototype* cannot override the static method *static-prototype* of type *type-name*",
		"cause": "It is forbidden to define a function with the same prototype/erasure as an inherited static function without adding the `static`modifier to the inheriting function prototype",
		"solution": "Add `static` modifier to the function prototype",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_method",
		"message": "Name clash: The method *func-prototype* of type *type-name* has the same erasure as *other-prototype*  of type *other-type* but does not override it",
		"cause": "It is forbidden to define a non-static function without the same prototype/erasure as an inherited non-static static function",
		"solution": "Change the *func-prototype* to be compatible with *other-prototype*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_method",
		"message": "Duplicate dispatch methods. Primitives cannot overload their wrapper types in dispatch methods",
		"cause": "It is forbidden to define a dispatch function without the same prototype/erasure as an inherited dispatch function",
		"solution": "Change the prototype of the dispatch function in order to be compatible with the prototype of the inherited dispatch function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_parameter_name",
		"message": "Duplicate parameter *name*",
		"cause": "You cannot define with the same *name* two formal parameters into the same function",
		"solution": "Rename one of the formal parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_parameter_name",
		"message": "Duplicate implicit parameter '*name*'",
		"cause": "You cannot define with the same *name* two formal parameters into the same function. In the context of the erroneous code, an implicit parameter may be defined and named `it`. You may have also explicitly defined a formal parameter named `it`. There is a conflict between the names",
		"solution": "Rename your explicit formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "Duplicate nested type *name*",
		"cause": "It is forbidden to define into an enclosing type two type declarations with the same given *name*",
		"solution": "Rename one of the inner types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "Duplicate type *name*",
		"cause": "It is forbidden to define into a SARL file two type declarations with the same given *name*",
		"solution": "Rename one of the types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "The type *name* is already defined",
		"cause": "It is forbidden to define into a SARL file two type declarations with the same given *name*",
		"solution": "Rename one of the types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.duplicate_type",
		"message": "The type *name* is already defined in file *filename*",
		"cause": "It is forbidden to define into a SARL file two type declarations with the same given *name*",
		"solution": "Rename one of the types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.equals_with_null",
		"message": "The operator '*name*' should be replaced by '*name*=' when null is one of the arguments",
		"cause": "This error message is generated when one of the (in)equality test operators `==` and `!=` is invoked with the null literal as left or right operand, e.g. `x == null` or `null == x`, and the other operand being of primitive type. These two test operators implement deep (in)equality tests. A better practice is to invoke the operator `===` or `!==`, which implement reference tests. Indeed, `null` value is a reference to nothing. It is better to compare a reference to another reference. And, the reference test operators are the most efficient for that",
		"solution": "Replace `==` by `===`, or `!=` by `!==`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.exception_declared_twice",
		"message": "Exception *type-name* is declared twice",
		"cause": "You have declared two times the same exception after a `throw` keyword",
		"solution": "Remove one occurrence of *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.exception_not_throwable",
		"message": "No exception of type *type-name* can be thrown; an exception type must be a subclass of Throwable",
		"cause": "You have specified a type after the `thrown` keyword that is not a subtype of `Throwable`. This type comes from the Java API, and represents all the throwable objects, e.g., the exceptions, into the virtual machine. You must given sub-types of `Throwable` after the `thrown` keyword",
		"solution": "Remove *type-name*; or replace it by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invisible_feature",
		"message": "Cannot access the private *feature* in a subclass context",
		"cause": "You try to access to a field that is declared as `private` into the super-type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invisible_feature",
		"message": "The method *feature* is not visible",
		"cause": "You try to access to a method that is declared as `private` into its enclosing type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invisible_feature",
		"message": "The field *feature* is not visible",
		"cause": "You try to access to a field that is declared as `private` into its enclosing type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.field_access_with_parentheses",
		"message": "Cannot access the *type-name* *feature-name* with parentheses",
		"cause": "This error is generated when you try to access to a field with parentheses. Let be the field `x` defined. The code `x()` causes this error because `x` is a field, not a method",
		"solution": "Remove the parentheses",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.field_already_initialized",
		"message": "The final field *name* may already have been assigned",
		"cause": "You try to change the value of a final field after it was initialized. A value could be given to a final field only one time, i.e. its initialization",
		"solution": "Remove the expression that try to change the final field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden annotation in a SARL program",
		"cause": "An annotation is used into the code. But this annotation is forbidden because it is reserved for internal usage, or it is not supported by the SARL compiler",
		"solution": "Remove the annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden annotation to the agent-oriented type *type-name*",
		"cause": "An active annotation, i.e. an annotation that causes a specific generation of code by the SARL compiler, is attached to an agent-oriented type, e.g. `agent`, `behavior`, etc. But, it is forbidden to attached the active annotation to an agent-oriented type",
		"solution": "Remove the active annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden annotation to the object-oriented type *type-name*",
		"cause": "An active annotation, i.e. an annotation that causes a specific generation of code by the SARL compiler, is attached to an object-oriented type, e.g. `class`, `interface`, etc. But, it is forbidden to attached the active annotation to an object-oriented type",
		"solution": "Remove the active annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Default value's expression cannot reference the not-pure operation: *name*",
		"cause": "This error message is generated when a reference to a non-pure function is detected into the expression of the default value for a formal parameter. Only pure functions could be used for building a default value expression in order to avoid unexpected side-effects",
		"solution": "Remove the reference to the not-pure function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden reference to not final field *name* from a constructor's default value expression",
		"cause": "This error message is generated when a reference to a not-final field is detected into the expression of the default value for a constructor's formal parameter. Only final fields could be used for building a default value expression of a constructor in order to avoid unexpected side-effects",
		"solution": "Remove the reference to the not final field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Forbidden feature call: *feature*",
		"cause": "This error is generated when a forbidden feature call is detected. The forbidden features to call are: `System::exit` when it is inde an agent-oriented type, e.g. `agent`; with a name containing the forbidden character &#x24;.; or the feature is part of a private API and the caller is not part of the private API",
		"solution": "Remove the call",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.forbidden_reference",
		"message": "Access restriction: The type *name* is not accessible",
		"cause": "This error is generated when a reference to the type with the given *name* is detected, and the type is not visible/accessible",
		"solution": "Remove type reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the primitive type *name*",
		"cause": "You try to create an instance of a primitive type named *name* with the `new` instruction. Since a primitive type is not object-oriented, it is impossible to create an instance of primitive type",
		"level": "error"
	},

	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the annotation type *name*",
		"cause": "You try to create an instance of an annotation named *name* with the `new` instruction. It is impossible to create an instance of annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the enum type *name*",
		"cause": "You try to create an instance of an enumeration named *name* with the `new` instruction. It is impossible to create an instance of enumeration",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the interface type *name*",
		"cause": "You try to create an instance of an interface named *name* with the `new` instruction. It is impossible to create an instance of interface",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the type parameter *name*",
		"cause": "You try to create an instance of a type parameter named *name* with the `new` instruction. Since the concrete type represented by the type parameter is not known at compile time, creation of an instance of *name* is impossible",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_class_instantiation",
		"message": "Cannot instantiate the *name*",
		"cause": "You try to create an instance of a type named *name* with the `new` instruction. The type with the given *name* cannot be instanciated due to several reasons, e.g., it is defiend as abstract, it has no visible constructor, etc",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.illegal_forward_reference",
		"message": "Cannot reference the field '*name*' before it is defined",
		"cause": "You try to have access to a field before it is defined within the sequence of statements ofyour code. This error should never append in SARL code. It was defined for \"safety\" reasons",
		"solution": "Move the field definition before its first usage",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_collision",
		"message": "The import '*package-1*.*name*' collides with the import '*package-2*.*name*'",
		"cause": "This error is generated when you define into the list of `import` two types with the same simple name. In this case, it is impossible to determine if an occurrence of *name* into the code refers to the type in the package *package-1* or in the package *package-2*",
		"solution": "Remove one of the `import`",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_conflict",
		"message": "The import '*package*.*name*' conflicts with a type defined in the same file",
		"cause": "You are importing a type with the given *name* into the given *package*. But, you have also defined a local type with the *name*. In this case, it is impossible to determine if an occurrence of *name* into the code refers to the local type or the imported type",
		"solution": "Rename the local type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_duplicate",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_unresolved",
		"message": "The import *name* cannot be resolved",
		"cause": "The *name* that is provided after an `import` cannot be found",
		"solution": "Remove the `import` statement",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_unsued",
		"message": "The import '*name*' is never used",
		"cause": "This issue message is generated when an `import` statement does not provide features that are used into the current file",
		"solution": "Remove `import` statement",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.import_wildcard_deprecated",
		"message": "The use of wildcard imports is deprecated",
		"cause": "You are importing all the types that are defined into a package with `import pkg.*`. This instruction has two major drawbacks. Firstly, the really used types within the current are not explicit because of the wildcard. Second, the SARL compiler loads in memory too much type definitions for compiling the current file",
		"solution": "Replace the wildcard by the really used types",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incomptible_return_type",
		"message": "Incompatible return type of dispatch method. Expected *inherited type* but was *specified type*",
		"cause": "This error message is generated when an overriding function has a *specified type* that is incompatible with the *inherited type* defined for the method into the super-type",
		"solution": "Replace the return type with a compatible type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incomptible_return_type",
		"message": "The return type is incompatible with *func-prototype*",
		"cause": "This error message is generated when an overriding function has a specified type that is incompatible with the inherited type defined for the method into the super-type",
		"solution": "Replace the return type with a compatible type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incompatible_throws_clause",
		"message": "The declared exception *exception-type* is not compatible with throws clause in *exception-list*",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, overridable functions as associated to a contract with their callers. This contract indicates that the prototype of the function will never changed, and the function will have the same thrown exceptions always. This contract must be fullfil by the overriding functions. This error message is generated when your overriding function has a list of exceptions after the `thrown` keyword that is not compatible with the list defined into the inherited function. An exception of type \"a\" in the overriding function must be also a \"b\", where \"a\" is equals to \"b\" or a sub-type of \"b\"",
		"solution": "Change the list of exceptions after `throws` keyword to the appropriate exception types",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incompatible_types",
		"message": "Type mismatch: cannot convert from *source-type* to *target-type*",
		"cause": "The value cannot be converted from the *source-type* to the *target-type* because there is neither implicit nor explicit conversion function",
		"solution": "Rewrite the expression in order to have a compatible type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incompatible_types",
		"message": "Incompatible types. Expected *expected-type* but was *actual-type*",
		"cause": "The value that is specified after a `return` statement has a type that is incompatible with the return type of the enclosing function",
		"solution": "Rewrite the return's expression in order to have a compatible type; or change the return type of the function to be compatible with those of the return expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incompatible_types",
		"message": "No exception of type *type-name* can be thrown; an exception type must be a subclass of Throwable",
		"cause": "Inside a `catch` statement, you have specified a *type-name* that does not correspond to a sub-type of `Throwable`. The parameter of the `catch` statement must be a throwable type, or a collection of throwable types",
		"solution": "Rewrite *type-name* by an appropriate throwable type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incomplete_cases_on_enum",
		"message": "The enum constant *name* needs a corresponding case label in this enum switch on *type-name*",
		"cause": "You have specified an enumerated value to a `switch` condition. The enumeration constant with the given *name* has not a corresponding `case` into the `switch`. It means that all the possible cases are not explicitly covered; It is preferrable they are all covered",
		"solution": "Add a `case` for the missed constant *name*",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.incomplete_cases_on_enum",
		"message": "The enum constants *list-of-names* need a corresponding case label in this enum switch on *type-name*",
		"cause": "You have specified an enumerated value to a `switch` condition. The enumeration constants with the given names have not corresponding `case` into the `switch`. It means that all the possible cases are not explicitly covered; It is preferrable they are all covered",
		"solution": "Add a `case` for each missed constant name",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.instance_access_to_static_member",
		"message": "The static *feature-type* *feature-name* should be accessed in a static way",
		"cause": "For a instance function, you try to access to a static feature using a non-static syntax, e.g. `obj.StaticFeature`. It is preferable to use the static call syntax, e.g. `MyType::StaticFeature`, where `MyType` is the type of the object `obj` from the previous example",
		"solution": "Replace the non-static syntax by the static syntax",
		"level": "d/org.eclipse.jdt.core.compiler.problem.staticAccessReceiver/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.interface_expected",
		"message": "Implemented interface must be an interface",
		"cause": "According to the syntax of SARL, a class implements interfaces. This error message indicates to you that one type after `implements` is not an interface",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.interface_expected",
		"message": "Extended interface must be an interface",
		"cause": "According to the syntax of SARL, an interface extends another interface. This error message indicates to you that the type after `extends` is not an interface",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.interface_expected",
		"message": "Invalid supertype. Expecting *feature*",
		"cause": "According to the syntax of SARL, a type (agent, capacity, etc.) extends another type. This error message indicates to you that the type after `extends` is not of a type that is expected. The name of the *feature* shows the expectation",
		"solution": "Remove the `extends` statement; or replace the invalid type by the appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_argument_types",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_cast",
		"message": "Cannot cast from *type-name-1* to *type-name-2*",
		"cause": "The operands of the cast operator `as` have not compatible types. SARL compiler has found no way to convert a value of the type with name *type-name-1*, which is the type of the left operand of the `as` operator, to a value of the type with name *type-name-2*, which is the right operand of the `as` operator",
		"solution": "Change the left expression in order to be of a compatible type with the right operand; or Replace *type-name-2* by an appropriate type name; or Define a \"to*type-name-2*()\" function if *type-name-2* is a class; or Define a \"*type-name-2Value()\" function if *type-name-2* is a primitive type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_cast",
		"message": "Cannot cast from void to *type-name-2*",
		"cause": "Since `void` represents the fact that there is not value, it is impossible to convert \"nothing\" to a value, whatever its type",
		"solution": "Remove `as` operator",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_constructor_argument",
		"message": "Cannot refer to an instance field *field-name* while explicitly invoking a constructor",
		"cause": "According to the standards of object-oriented programming, nothing could append into an object before it was constructed. It means that when you are calling a constructor from inside a constructor's block of code, the object is not yet built. Consequently, you cannot have access to the object's fields (not static)",
		"solution": "Rewrite the arguments to avoid the access to the object's field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_constructor_argument",
		"message": "Cannot refer to an instance method while explicitly invoking a constructor",
		"cause": "According to the standards of object-oriented programming, nothing could append into an object before it was constructed. It means that when you are calling a constructor from inside a constructor's block of code, the object is not yet built. Consequently, you cannot have access to the object's method (not static)",
		"solution": "Rewrite the arguments to avoid the access to the object's method",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_constructor_invocation",
		"message": "Constructor call must be the first expression in a constructor",
		"cause": "According to the standards of object-oriented programming, nothing could append into an object before it was constructed. It means that the first possible instruction within any constructor's code is a call to another constructor. This call may be explicit or implicit. This error is generated by your constructor's code starts with statements that are not a constructor calls, followed by a constructor call",
		"solution": "Move the constructor call first",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_early_exit",
		"message": "Return is not allowed in creation expression",
		"cause": "This error message is generated when a `return` statement is defined in a context that cannot allow a return, such as a creation expression",
		"solution": "Remove the `return` statement",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_generic_argument_types",
		"message": "*any-message*",
		"cause": "This error message is generated when you pass an invalid type to a generic parameter type. *Caution: this issue seems not to have a message template from the Xtext/Xbase source code*",
		"solution": "Change the type argument",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_identifier",
		"message": "'*name*' is not a valid identifier",
		"cause": "This error is generated when you are using an identifier that is corresponding to a keyword of the Java programming language. Since the SARL compiler create Java source file, in order to make the generated files compilable, any variable with a name equals to a JAva keyword must be avoided",
		"solution": "Change the *name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_inner_expression",
		"message": "This expression is not allowed in this context, since it doesn't cause any side effects",
		"cause": "This error is generated when you write an expression without side effect, where one is expected. For example, the following code generates this error:\n&p.lt;code&p.gt;def fct : void {&p.lt;br&p.gt;&nbsp;&nbsp;var x = 1&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nIn this case, the variable declaration has not side effect; and should not be used in this context",
		"solution": "Remove the expression without side-effect",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_inner_expression",
		"message": "Expression with side effect is not allowed in guards",
		"cause": "The guard that is specified for a behavior unit may have side effect, i.e. it may modify the state of the current agent/behavior/skill, or of another object. According to the SARL specification, the behavior units' guards must not have any side-effect because the guard's expression could be evaluated in parallel for different behavior units on the same event. In order to be consistent between the different evaluations of the guard, the guard expression cannot change the state of any object",
		"solution": "Rewrite the guard expression to avoid the uses of side-effect expressions",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_instanceof",
		"message": "Cannot perform instanceof check against parameterized type *type-name*",
		"cause": "You have written a `instanceof` operator with a right operand containing a generic type parameter, e.g. `x instanceof MyType&p.lt;T&p.gt;`. It is impossible for now to the SARL compiler to consider the generic type parameter, e.g. `T`",
		"solution": "Remove the generic type parameter from the right operand's expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_instanceof",
		"message": "Cannot perform instanceof check against primitive type *type-name*",
		"cause": "You have written a primitive type as right operand of the `instanceof` operator. Since a primitive type is not object-oriented, it is impossible to test if an object is of a primitive type using the `instanceof` operator",
		"solution": "Remove `instanceof` operator; or Replace the primitive type by its object-oriented equivalent type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_instanceof",
		"message": "Incompatible conditional operand types *type-name-1* and *type-name-2*",
		"cause": "When you are testing expression typing with `instanceof`, the types of the operands are not compatible. It means that the values of the operands cannot be compared. Therefore, the `instanceof` operator becomes useless",
		"solution": "Remove the `instanceof` operator; or Rewrite the `instanceof` expression to have compatible types for both operands",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_multitype_part",
		"message": "The caught *type-name* is redundant",
		"cause": "You have specified multiple types, including *type-name*, into a multi-`catch` statement. The *type-name* is specified more than one time. You must not specify a type more than one time",
		"solution": "Remove one occurrence of *type-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_multitype_part",
		"message": "The *type-name-1* is already covered by the caught *type-name-2*",
		"cause": "You have specified multiple types, including *type-name-1* and *type-name-2*, into a multi-`catch` statement. The *type-name-1* is redundant because it is a sub-type of *type-name-2*",
		"solution": "Remove *type-name*-1",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_mutable_variable_access",
		"message": "Cannot *expression* refer to the non-final variable *var-name* inside a lambda expression",
		"cause": "You have written an expression inside a closure/lambda expression that is referring a variable that is not marked as final. In this case, the state of the variable becomes unpredictable for the internal class that is supporting the lambda expression implementation (due to the targeting to Java). That's why only final (or quasi-final) variables could be used in lambda expressions",
		"solution": "Replace `var` definition of the variable by a `var` definition; or Use another final variable from the lambda expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalidNumberFormat",
		"message": "Invalid number format: *explaination*",
		"cause": "A number literal has not a valid syntax",
		"solution": "Change the number literal to fullfil the number syntax",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_arguments",
		"message": "Invalid number of arguments. The *feature-type* *feature-prototype* is not applicable without arguments",
		"cause": "You are calling a feature (method or constructor) without arguments. But, the called feature required to have arguments",
		"solution": "Add arguments into your calling expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_arguments",
		"message": "Invalid number of arguments. The *feature-type* *feature-prototype* is not applicable for the arguments *list-of-arguments*",
		"cause": "You are calling a feature (method or constructor) with a *list-of-arguments*. But, the called feature required a different number of arguments",
		"solution": "Call the feature with the correct number of arguments",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_type_arguments",
		"message": "Incorrect number of arguments for type *type-name* ; it cannot be parameterized with arguments *type-arguments*",
		"cause": "You are referencing a type with a list of generic type arguments (*list-arguments*). But, the referenced type required a different number of generic type arguments",
		"solution": "Reference the type with the correct number of arguments",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_number_of_type_arguments",
		"message": "Invalid number of type arguments. The *feature-type* *feature-name* is not applicable for the type arguments *type-arguments*",
		"cause": "You are calling a feature (method or constructor) with a list of generic type arguments (*list-arguments*). But, the feature required a different number of generic type arguments",
		"solution": "Call the feature with the correct number of arguments",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_operand_types",
		"message": "Incompatible operand types *left* and *right*",
		"cause": "When you are testing expression equality with `===`, the types of the operands are not compatible. It means that the values of the operands cannot be compared",
		"solution": "Rewrite your code in order to have compatible types for both operands",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Invalid return inside throw",
		"cause": "It is forbidden to specify a `return` statement into a `throw` expression because the outer early-exit point (`throw`) could be never reached due to the execution of the inner early-exit point (`return`). It is inconsistent to do a regular return for a function inside the expression of an exceptional exit from the same function",
		"solution": "Remove `return` from the `throw` expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Return cannot be nested",
		"cause": "It is forbidden to specify a `return` statement into another `return` expression because the outer early-exit point could be never reached due to the execution of the inner early-exit point. It is inconsistent to do a return for a function inside the expression that computes another value to be returned from the same function",
		"solution": "Remove the inner `return` from the outer `return` expression",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Invalid return's expression",
		"cause": "SARL compiler infers that the type of the expression after a `return` statement is of type `void`. It is impossible to return \"nothing\" when a value is expected",
		"solution": "Change the return expression in order to compute a value of the appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "Void functions cannot return a value",
		"cause": "You are specifying a `return` statement with an expression inside a procedure, i.e. a function returning \"nothing\". Is it inconsistent to compute a value to be returned while the function does not return it",
		"solution": "Remove the expression from the `return` statement",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_return",
		"message": "The function must return a result of type *type-name*",
		"cause": "An incompatibility between the type of the expression after a `return` statement and those of the return value of the enclosing function is detected. Both types must be compatible, i.e., the type of the expression after the `return` statement must be equal to or a sub-type of the function's return type",
		"solution": "Update the expression of the `return` statement to have an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_super_call",
		"message": "Cannot call super of an anonymous class from a lambda expression",
		"cause": "A closure/lambda expression is implemented by an anonymous class at the background, i.e. Java. You try to use the `super` statement that represents the instance viewed as the super-type of the associated anonymous class. However, it is forbidden to use `super` because the closure/lambda expression hides the background implementation, inclusing `super`",
		"solution": "Remove `super`",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_try_resource_type",
		"message": "The resource '*var-name*' of type *type-name* does not implement java.lang.AutoCloseable",
		"cause": "The try-with-resource statement enables you to automatically close an opened resource (file, socket, etc.). The given resource, named *var-named* must implement the interface `AutoCloseable` in order to be able to be automatically closed. This constraint comes from the Java underground API",
		"solution": "Change the resource by using one that is auto-closeable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type",
		"message": "Undefined type for the formal parameter *name*",
		"cause": "A type specification is missed for the formal parameter with the given *name*",
		"solution": "Add a type to the formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type",
		"message": "Undefined type for the default value of the formal parameter *name*",
		"cause": "The type of the default for the formal parameter with the given *name* cannot be infered by the SARL compiler",
		"solution": "Change the default value's expression in order to make its type inferable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type",
		"message": "'void[]' is not a valid type",
		"cause": "This error is generated when you are specifying a type literal representing an array of `void`, e.g. `void[]` or `void[][]`. An array of void cannot be created in memory. It is therefore impossible to specify this type with a type literal",
		"solution": "Replace `void` by and appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_arguments_on_type_literal",
		"message": "Invalid type argument. Type arguments cannot be applied to the type literal *name*",
		"cause": "You have specified a generic type argument into a type literal such as `typeof`; that is invalid. For example, `typeof(Collection)` is valid; but `typeof(Collection&p.lt;String&p.gt;)` is not",
		"solution": "Remove the generic type argument",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_arguments_on_type_literal",
		"message": "Invalid type arguments. Type arguments cannot be applied to the type literal *name*",
		"cause": "You have specified generic type arguments into a type literal such as `typeof`; that is invalid. For example, `typeof(Collection)` is valid; but `typeof(Collection&p.lt;String, Integer&p.gt;)` is not",
		"solution": "Remove the generic type arguments",
		"solution": "x",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_parameter_bounds",
		"message": "The array type *type-name* cannot be used as a type parameter bound",
		"cause": "It is forbidden to use an array type into the generic type bounds, e.g. `&p.lt;? extends Integer[]&p.gt;`",
		"solution": "Replace the array into the generic bounds by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_type_parameter_bounds",
		"message": "The type parameter %name% cannot be used as a type parameter bound with additional bounds",
		"cause": "If you put a generic type paramater as bounds of another generic type parameter, it is forbidden to add more bounding constraints. For example, `&p.lt;A, B extends A&p.gt;` is valid. But, `&p.lt;A, B extends A & Cloneable&p.gt;` is invalid",
		"solution": "Remove the additional bounding constraint",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "void is an invalid type for the create method *func-prototype*",
		"cause": "Create method is defined as a design pattern for creating objects in memory. By design, they are supposed to return the created object and not void",
		"solution": "Replace the void return type by the type of the created object",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "The primitive type cannot be a type argument",
		"cause": "It is forbidden to put primitive types as generic type parameters, e.g. `Collection&p.lt;int&p.gt;`. You must use only classes as generic type parameters, e.g. `Collection&p.lt;Integer&p.gt;`",
		"solution": "Replace the primitive type by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "The primitive 'void' cannot be the type of a parameter",
		"cause": "A formal parameter must have a type. Consequently, `void` cannot be specified as the type of a formal parameter",
		"solution": "Replace `void` by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "The primitive 'void' cannot be the type of a function parameter",
		"cause": "This error is generated when a reference to a function, a.k.a. as pointer to a function, is specified with a `void` type. A function has parameters and returns values. It is not `void`",
		"solution": "Replace `void` by an appropriate pointer to a function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Primitive void cannot be used here",
		"cause": "This message is generated in to cases.\na) Generic type argument: it is forbidden to put primitive `void` as generic type arguments, e.g. `Collection&p.lt;void&p.gt;`.\nb) Guard type into a switch case: it is forbidden to put primitive `void` as guard type, e.g. `void case 1`",
		"solution": "Replace `void` by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "void is an invalid type for the variable *name*",
		"cause": "Since a variable is supposed to contain a value, it is important to specify the size of memory that is occupied bythe variable. This specification is done by giving a type to the variable. `void` is not a valid type in this context",
		"solution": "Replace `void` by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Primitives cannot be used as type arguments",
		"cause": "It is forbidden to put primitive types as generic type arguments, e.g. `Collection&p.lt;int&p.gt;`. You must use only classes as generic type arguments, e.g. `Collection&p.lt;Integer&p.gt;`",
		"solution": "Replace the primitive type by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Primitives are not allowed as type guards",
		"cause": "It is forbidden to put primitive type as guard type, e.g. `int case 1`",
		"solution": "Replace the primitive type by its appropriate equivalent class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "Create method *name* may not declare return type void",
		"cause": "Create method is defined as a design pattern for creating objects in memory. By design, they are supposed to return the created object and not void",
		"solution": "Replace the void return type by the type of the created object",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_void",
		"message": "The inherited return type void of *name* is invalid for create method",
		"cause": "Create method is defined as a design pattern for creating objects in memory. By design, they are supposed to return the created object and not void",
		"solution": "Replace the void return type by the type of the created object",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_type_parameter",
		"message": "Cannot perform type switch against type parameter *name*. Use its erasure Object instead since further generic type information will be erased at runtime",
		"cause": "You specify a generic type parameter as the type guard of a `case`, e.g. `T case 1`. Since there is no keept information about the generic types at runtime, the `case` statement cannot filter according to the type of the value. It is therefore recommended to use `Object` as the type guard",
		"solution": "Remove the type guard",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_type_parameter",
		"message": "Illegal class literal for the type parameter *name*",
		"cause": "You specify a generic type parameter as a type literal, e.g. `typeof(T)`. Since there is no keept information about the generic types at runtime, the `typeof` operator cannot reply the class at runtime",
		"solution": "Replace *name* by an appropriate type from the erasure of *name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_type_parameter",
		"message": "Cannot perform instanceof check against type parameter *name*. Use its erasure *erasure-name* instead since further generic type information will be erased at runtime",
		"cause": "You specify a generic type parameter as the right operand of an `instanceof`, e.g. `x instanceof T`. Since there is no keept information about the generic types at runtime, the `instanceof` operator cannot proceed. The *erasure-name* is the base definition of *name* related to its bounds",
		"solution": "Replace *name* by *erasure-name*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_use_of_wild_card",
		"message": "Wildcard types are not allowed in this context",
		"cause": "It is forbidden to put wildcard as generic type parameters, e.g. `Collection&p.lt;?&p.gt;`. You must use only classes as generic type parameters, e.g. `Collection&p.lt;Integer&p.gt;`",
		"solution": "Replace the wildcard by an appropriate class",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_wildcard_constraints",
		"message": "Invalid type constraint. Cannot use multiple upper bounds in wildcards",
		"cause": "Inside a type reference, you have specified a type constraints with too much upper bounds, e.g. `new MyType&p.lt;? extends Number &amp; CharSequence&p.gt;`. Currently, SARL does not support multiple upper bounds into the generic type references",
		"solution": "Modify the bounds to have maximum one upper bound",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.invalid_wildcard_constraints",
		"message": "Invalid type constraint. Cannot use multiple lower bounds in wildcards",
		"cause": "Inside a type reference, you have specified a type constraints with too much lower bounds, e.g. `new MyType&p.lt;? super Number &amp; CharSequence&p.gt;`. Currently, SARL does not support multiple lower bounds into the generic type references",
		"solution": "Modify the bounds to have maximum one lower bound",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.java_style_type_cast",
		"message": "Use 'as' keyword for type casting",
		"cause": "SARL has detected possible improper usage of the parentheses, i.e., a type reference enclosed by parentheses is found. This syntax is well known is other programming languages such as Java or C++, as the casting operator. However, the casting operator in SARL is `as`. For example, this error is detected when you starts a code block with the improper syntax, e.g. `{(Integer) 1}`",
		"solution": "Replace the Java-like casting operator by `as`",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.local_var_access_with_parentheses",
		"message": "Cannot access the *type-name* *feature-name* with parentheses",
		"cause": "This error is generated when you try to access to a local variable with parentheses. Let be the local variable `x` defined. The code `x()` causes this error because `x` is a variable, not a method",
		"solution": "Remove the parentheses",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.method_access_without_parentheses",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_attribute_definition",
		"message": "The annotation must define the attribute '*name*'",
		"cause": "An annotation needs to have a specified value. This error message is generated when no value is specified into the annotation",
		"solution": "Add a value to the annotation",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_constructor",
		"message": "No default constructor in super type *other-type*. *type-name* must define an explicit constructor",
		"cause": "You have define a type named *type-name* with a default constructor. But, the super-class does not have a default constructor. It is then impossible for your implicit default constructor to invoke a default constructor from the super-class. You must define explicitly your own constructor. *This issue should never occur because the constructors from the super type are inherited when there is no explicit constructor defined*",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_initialization",
		"message": "Value must be initialized",
		"cause": "Final variables, a.k.a. value, could be declared with `val`, and must be initialized when they are declared. You have declared a final variable that is never initialized",
		"solution": "Add initialization value to the final variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_synchronized",
		"message": "The overridden method is synchronized, the current one is not synchronized",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, overridable functions as associated to a contract with their callers. This contract indicates that the prototype of the function will never changed, and the function will have the same modifiers always. This contract must be fullfil by the overriding functions. This warning message is generated when your overriding function has not the `synchronized` modifier, and the inherited function has the `synchronized` modifier. It is a good practice to exhibit the same modifiers as the inherited function",
		"solution": "Add `synchronized` modifier to your function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_type",
		"message": "Missing implemented type '*type-name-1*' for '*type-name-2*'",
		"cause": "SARL detects for the declaration of the type named *type-name-2* that an implementation specification after `implements` is missed. The expected implementation must be a type that is equal to or a sub-type of the type named *type-named-1*",
		"solution": "Add an appropriate implemented type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.missing_type",
		"message": "Type cannot be derived",
		"cause": "Within a variable declaration with `var` or `val`, no type was specified. SARL was failed to infer the type of the variable, notably because an initialization expression is missed for the variable. Because a variable must have a type, it is forbidden to let the variable type free",
		"solution": "Add an explicit type to the variable, or Add an initialization expression for the variable",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.must_invoke_super_constructor",
		"message": "No default constructor in super type *type-name*. Another constructor must be invoked explicitly",
		"cause": "You have define a type extending the type *type-name* and with an explicit constructor. Inside the code of this explicit constructor, you call the default constructor (implicitly or explicitly). But, the super-type does not have a default constructor",
		"solution": "Update you constructor code in order to invoke a constructor of the super-type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_enclosing_instance_available",
		"message": "The enclosing type does not extend or implement the interface *name*",
		"cause": "Your are calling a feature (method or field) from the super-type by using the syntax `super.feature`. The super-type does not implement the interface *name* that is required to access to the specified feature",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.no_enclosing_instance_available",
		"message": "No enclosing instance of the type *name* is accessible in scope",
		"cause": "You are referencing a feature within the type *type* that is defined non-statically. But, these is no accessible instance of the type *name* within the enclosing types. The following example is a typical example for this error:\n&p.lt;code&p.gt;class A {&p.lt;br&p.gt;&nbsp;&nbsp;def f : void {}&p.lt;br&p.gt;&nbsp;&nbsp;static class B {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;def g : void {&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&p.lt;br&p.gt;&nbsp;&nbsp;&nbsp;&nbsp;}&p.lt;br&p.gt;&nbsp;&nbsp;}&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nThe reference to `f` causes this error because the instance of `A` is inaccessible from `B` due to its `static` declaration",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.not_instantiable",
		"level": "ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.null_safe_feature_call_on_primitive",
		"message": "Cannot use null-safe feature call on primitive receiver",
		"cause": "Null-safe call of an method, e.g. `obj?.feature`, enables you to test the nullity of an object before calling a feature on  it. But, you have applied the null-safe call on a primitive type variable, i.e. `obj` is of primitive type. This is impossible because a primitive variable does not contain an object",
		"solution": "Remove the null-safe operator",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.null_safe_feature_call_on_primitive_valued_feature",
		"message": "Null-safe call of primitive-valued feature *feature-name*, default value *value* will be used",
		"cause": "This issue message is generated when a null-safe test is used for computing a primitive-type value. For example, the code `list?.isEmpty` explicitly replies the value of `isEmpty` if the `list` is not null. But when `list` is null, nothing indicates what could be the boolean value to give. SARL compiler assumes the default value for the primitive type, e.g. `false` for boolean.\nThis issue message is also generated when your are using an incomplete if-then statement, e.g. `var b = if (condition) true`. There is no `else`, so that the default value for the primitive type is assumed if the condition is evaluated to false",
		"solution": "Update your code to have a complete coverage of the cases",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.obsolete_cast",
		"message": "Unnecessary cast from *type-name-1* to *type-name-2*",
		"cause": "You are using a cast operator `as`. But, the type of the left-operand expression is already compatible with the specified type as right operand. In other words, it is not necessary to cast explicitly the left expression to the right type",
		"solution": "Remove `as` operator",
		"level": "d/org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.obsolete_instanceof",
		"message": "The expression of type *type-name-1* is already of type *type-name-2*",
		"cause": "You are using `instanceof`. But, the type of the left-operand expression is already compatible with the specified type as right operand. In other words, it is not necessary to test the type of the expression again the type; or the `instanceof` operator is always evaluated to true",
		"solution": "Remove `instanceof` operator, and any \"else\" statement that is associated with the operator",
		"level": "d/org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.operation_without_parentheses",
		"message": "Method call without parentheses",
		"cause": "This error message is generated when a function is defined without a formal parameter, e.g. `def fct()`, and this function is called without parentheses, e.g. `fct`. In several programming standards, it is considered as a good practice to write the parentheses for each method call, even if there is no argument to pass to",
		"solution": "Add `()`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.operation_without_parentheses",
		"message": "Constructor call without parentheses",
		"cause": "This error message is generated when a constructor is defined without a formal parameter, e.g. `new ()`, and this constructor is called without parentheses, e.g. `this`. In several programming standards, it is considered as a good practice to write the parentheses for each constructor call, even if there is no argument to pass to",
		"solution": "Add `()`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.overridden_final",
		"message": "Attempt to override final method *func-prototype*",
		"cause": "You define a function with the given prototype *func-prototype* that is overriding an inherited function. But, the inherited function was defined as not overridable, with the `final` modifier. You cannot override a function that is not overridable",
		"solution": "Remove your function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.overridden_final",
		"message": "Attempt to override final class",
		"cause": "You define a class that is extending another class. But, the super class was defined as not extendable, with the `final` modifier. You cannot extend a class that is not extendable",
		"solution": "Change the super-type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.override_reduces_visibility",
		"message": "Synthetic dispatch method reduces visibility of overridden method *name*",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, overridable functions as associated to a contract with their callers. This contract indicates that the prototype of the function will never changed, and the function will have the same accessibility/visibility always. This contract must be fullfil by the overriding functions. This error message is generated when your overriding function has a visibility lower than the visibility of the inherited function",
		"solution": "Change the visibility of your function by moving up at least to the same visibility as the inherited function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.override_reduces_visibility",
		"message": "Cannot reduce the visibility of the overridden method *name*",
		"cause": "According the inheritance definition, that is common to SARL and the object-oriented programming languages, overridable functions as associated to a contract with their callers. This contract indicates that the prototype of the function will never changed, and the function will have the same accessibility/visibility always. This contract must be fullfil by the overriding functions. This error message is generated when your overriding function has a visibility lower than the visibility of the inherited function",
		"solution": "Change the visibility of your function by moving up at least to the same visibility as the inherited function",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.primitive_compared_to_null",
		"message": "The operator '*name*' is undefined for the argument types *type-name* and null",
		"cause": "This error message is generated when an (in)equality test operator, i.e., `==`, `===`, `!=` or `!==`, is invoked with the null literal as right operand, e.g. `x == null`, and the left operand being of primitive type. The problem is due to the usage of the keyword `null` that is not corresponding to a specific type. In this case, the SARL compiler cannot determine the best operator implementation",
		"solution": "Initialize to `null` a local variable with the expected type for the right operand, and use this local variable as right operand",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.primitive_compared_to_null",
		"message": "The operator '*name*' is undefined for the argument types null and *type-name*",
		"cause": "This error message is generated when an (in)equality test operator, i.e., `==`, `===`, `!=` or `!==`, is invoked with the null literal as left operand, e.g. `null == x`, and the right operand being of primitive type. The problem is due to the usage of the keyword `null` that is not corresponding to a specific type. In this case, the SARL compiler cannot determine the best operator implementation",
		"solution": "Initialize to `null` a local variable with the expected type for the left operand, and use this local variable as left operand",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.primitive_compared_to_null",
		"message": "The operator '?:' is undefined for arguments of type *type-name*",
		"cause": "This error message may be generated when your are using the elvis operator, with a primitive type value as left operand and the `null` literal as right operand, e.g. `x ?: null`. The problem is due to the usage of the keyword `null` that is not corresponding to a specific type. In this case, the SARL compiler cannot determine the best operator implementation",
		"solution": "Initialize to `null` a local variable with the expected type for the right operand, and use this local variable as right operand",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.raw_type",
		"message": "*name* is a raw type. References to generic type *name* should be parameterized",
		"cause": "You are referencing a generic type with the given *name* without specifying its generic type arguments",
		"solution": "Add the missed generic type arguments",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.raw_type",
		"message": "*expression* uses the raw type *name*. References to generic type *name* should be parameterized",
		"cause": "The given *expression* is referencing a generic type with the given *name* without specifying its generic type arguments",
		"solution": "Add the missed generic type arguments",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.redundant_case",
		"message": "Redundant case",
		"cause": "You have written a case without block of code that falls through the default case. It may be a piece of code like:\n&p.lt;code&p.gt;switch (v) {&p.lt;br&p.gt;&nbsp;&nbsp;case 1,&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nIt is clear that `case 1` falls through a case that is not given. In this case, it is considered as an error because the fall-through cannot be implemented",
		"solution": "Remove the fall-through case; or add a block of code to the redundant case",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.redundant_case",
		"message": "Redundant case",
		"cause": "You have written a case without block of code that falls through the default case. It may be a piece of code like:\n&p.lt;code&p.gt;switch (v) {&p.lt;br&p.gt;&nbsp;&nbsp;case 1,&p.lt;br&p.gt;&nbsp;&nbsp;default: {}&p.lt;br&p.gt;}&p.lt;/code&p.gt;\nIt is clear that `case 1` is redundant with `default` since this last is covering the `1` value",
		"solution": "Remove the redundant case",
		"level": "warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The field *field-name* has an illegal argument type",
		"cause": "One of the generic type arguments that is implicitly associated to the field *field-name* is specified as to be `void` or non-found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The method *func-prototype* from the type *type-name* has an illegal argument type",
		"cause": "One of the generic type arguments that is implicitly associated to the given method is specified as to be `void` or non-found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The constructor *constructor-prototype* has an argument of void type",
		"cause": "One of the generic type arguments that is implicitly associated to the given constructor is specified as to be `void` or non-found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The field *field-name* refers to the missing type *name*",
		"cause": "The given field is associated to a type that was not found into the classpath. The non-found type may be the raw type of the field, or one of the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The method *func-prototype* from the type *type-name* refers to the missing type *name*",
		"cause": "The given method is associated to a type that was not found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.refer_invalid_types",
		"message": "The constructor *constructor-prototype* refers to the missing type *name*",
		"cause": "The given constructor is associated to a type that was not found into the classpath",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make a static reference to the non-static *feature-type* *feature-name* from the type *type-name*",
		"cause": "You are making a reference to a non-static feature (function call or field reference) from a static context within the type *type-name*. Accessing to a non-static feature needs to provide the instance of the object to access to; that is missed from a static context",
		"solution": "Add the missed object reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make a static reference to the non-static *feature-type* *feature-name*",
		"cause": "You are making a reference to a non-static feature (function call or field reference) from a static context. Accessing to a non-static feature needs to provide the instance of the object to access to; that is missed from a static context",
		"solution": "Add the missed object reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make a static reference to the non-static type *name*",
		"cause": "When you are defining the generic type arguments, you have to specify types as arguments, e.g. `Collection&p.lt;MyType&p.gt;`. Generic type arguments could only refer to statically declared types",
		"solution": "Replace the non-static type reference by an appropriate static type reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make an implicit reference to this from a static context",
		"cause": "You are making an implicit reference to the current object `this` from a static context. Since it is a static context, `this` does not exist or is not accessible from it",
		"solution": "Add the missed object reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot use *name* in a static context",
		"cause": "You cannot reference a type with *name* from a static context when the type *name* is not statically defined",
		"solution": "Replace the non-static type reference by an appropriate static type reference",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.static_access_to_instance_member",
		"message": "Cannot make an implicit static reference to the non-static extension *name*",
		"cause": "You have defined a non-static extension in the enclosing code. And , you are making a reference to a non-static extension feature (function call usually) from a static context. Accessing to a non-static feature needs to provide the instance of the object to access to; that is missed from a static context",
		"solution": "Replace implicit reference by explicit reference to the right object",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.suspiciously_overloaded_feature",
		"message": "Suspiciously overloaded method. The *feature-type* *list-of-features* overloads the *feature-type* *list-of-rejected-features*",
		"cause": "You are calling a feature (method, field, etc.). The target feature that is find by the SARL compiler seems to overload another feature, but not direct through an overriding. Indeed, with the extension method mechanism, candidates for being the target feature may be defined in the current type (regular linking), or imported from static types or from objects (extension linking). The selected target feature seems to hide another feature outside the inheritance mechanism between the types",
		"solution": "Rewrite your code to remove the suspicious call",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "The field *name* needs an explicit type since there is no initialization expression to infer the type from",
		"cause": "You have defined a field without explicitly specifying its type. However, there is not initialization epxression assigned to the field for determining the field's type",
		"solution": "Define explicitly the type of the field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "Cannot infer type from recursive usage. Type 'Object' is used",
		"cause": "You code has a type-free feature, e.g. a local variable. SARL cannot infer the type of the feature because a cycle is detected regarding the type definitions",
		"solution": "Define explicitly the type of the feature",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "Cannot infer type",
		"cause": "It is too complex for the SARL compiler to infer the type of the marked feature",
		"solution": "Define explicitly the type of the feature",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "There is no context to infer the closure's argument types from. Consider typing the arguments or put the closures into a typed context",
		"cause": "This error is generated when the SARL compiler cannot infer the type of a formal parameter of a closure/lambda expression from the usage context",
		"solution": "Define explicitly the formal parameters within the closure; or Make more explicit within the enclosing context the type of the closure's formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_little_type_information",
		"message": "There is no context to infer the closure's argument types from. Consider typing the arguments or use the closures in a more specific context",
		"cause": "This error is generated when the SARL compiler cannot infer the type of the first formal parameter of a closure/lambda expression from the usage context",
		"solution": "Define explicitly the formal parameters within the closure; or Make more explicit within the enclosing context the type of the closure's first formal parameter",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.too_many_params_in_closure",
		"message": "The maximum number of parameters for a closure is six",
		"cause": "A constrain given by the underground Java API is the maximum number of formal parameters that could be defined for a closure/lambda expression",
		"solution": "Reduce the number of formal parameters of your closure",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_argument_on_non_generic_type",
		"message": "The type *type-name* is not generic; it cannot be parameterized with arguments *type-arguments*",
		"cause": "You have specified generic type parameters to a type that does not accept generic type parameters, e.g. `Object&p.lt;String&p.gt;`, `int&p.lt;String&p.gt;`, `MyEnum&p.lt;String&p.gt;`, `MyAnnotation&p.lt;String&p.gt;`",
		"solution": "Remove the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_bounds_missmatch",
		"message": "Invalid type: '*type*'. Only *type* can be used after the keyword '*kw*'",
		"cause": "The type that is specified after the given keyword *kw* is not of the expected type. For example, after a `on` statement, only a SARL event is expected",
		"solution": "Replace *type* by an appropriate event type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_bounds_missmatch",
		"message": "Bounds mismatch: The type arguments *type-arguments* are not a valid substitute for the bounded type parameters *parameters* of the *feature-type* *feature-signature*",
		"cause": "The type that is specified after a `on` statement is not a SARL event, i.e. a sub-type of the type `Event`",
		"solution": "Replace *type* by an appropriate event type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_bounds_missmatch",
		"message": "Bounds mismatch: The type argument *type-argument* is not a valid substitute for the bounded type parameter *parameter* of the *feature-type* *feature-signature*",
		"cause": "The generic *type-argument* does not match the type bounding constraints of the corresponding generic type parameter of the specified feature. If the bounding constraint is `extends`, then the *type-argument* is not a sub-type of the one specified into the constraint. If the bounding constraint is `super`, then the *type-argument* is not a super-type of the one specified into the constraint",
		"solution": "Replace *type-argument* by an appropriate type",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.type_parameter_forward_reference",
		"message": "Illegal forward reference to type parameter *name*",
		"cause": "Since Java 5, forward references in type parameters are not allowed. Let define a list of generic type parameters `&p.lt;A, B extends C, C extends A&p.gt;`. In the previous example, `C` has a backward reference to `A`; and `B` has a forward reference to `C`. Then, `extends C` causes the generation of this error message. In other words, a local generic type parameters msut be declared before its usage into the bounds of another generic type parameter",
		"solution": "Change the order of the generic type parameters",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unexpected_invocation_on_type_literal",
		"message": "The syntax for type literals is typeof(*name*) or *name",
		"cause": "The type literal, i.e. the name of the type, with *name* must follow a string syntax, that is explained in the error message",
		"solution": "Use the correct syntax",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unhandled_exception",
		"message": "Unhandled exception type *type-name* thrown by automatic close() invocation on *feature*",
		"cause": "An exception is declared to be throwable by the `close()` function, which is automatically/implicitly invoked. This exception is not catched. This is not an error stricly because SARL compiler is able to propagate the definition of the exceptions to the enclosing function or constructor",
		"solution": "Add `catch` statement",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unhandled_exception",
		"message": "Unhandled exception types *type-name-1* and *type-name-2*",
		"cause": "Exceptions have been declared to be throwable by instructions within the code block of an method or a constructor. But, the method or the constructor has no declaration of *type-name-1* and *typename-2* with `throws`. This is not an error stricly because SARL compiler is able to propagate the definition of the exceptions to the enclosing function or constructor",
		"solution": "Add *type-name-1* and *type-name-2* to `throws`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unhandled_exception",
		"message": "Unhandled exception type *type-name*",
		"cause": "Exception *type-name* has been declared to be throwable by instructions within the code block of an method or a constructor. But, the method or the constructor has no declaration of *type-name* with `throws`. This is not an error stricly because SARL compiler is able to propagate the definition of the exceptions to the enclosing function or constructor",
		"solution": "Add *type-name* to `throws`",
		"level": "c/ignore"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unqualified_super_call",
		"message": "Unqualified super reference is not allowed in interface context",
		"cause": "You try to use the `super` statement from an interface. Because an interface has no associated instance of object and consequently not super-type instance, you cannot call `super`",
		"solution": "Remove `super`",
		"level": "c/error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_case",
		"message": "Unreachable code: The case can never match. It is already handled by a previous condition",
		"cause": "You have specified a `case` that is already handled by another `case` before. It means that this `case` will never match because the previous one will do",
		"solution": "Remove `case`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_catch_block",
		"message": "Unreachable code: The catch block can never match. It is already handled by a previous condition",
		"cause": "You have specified a `catch` that is already handled by another `catch` before. It means that this `catch` will never match because the previous one will do",
		"solution": "Remove `catch`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable expression",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the unreachable code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the dead code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Dead code: The variable *name* will never be assigned",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the dead code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code",
		"cause": "This error message is generated when a line of code cannot be reached in all the case. For example a loop with a `true` condition should never exit from looping. Then, all the statements after the loop becomes unreachable",
		"solution": "Remove the dead code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code. The last argument expression does not complete normally",
		"cause": "This error message is generated when the evaluation of the last argument causes a stop of the execution sequence that avoid to call the method/constructor for switch the argument is computed",
		"solution": "Remove the unreachable code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_code",
		"message": "Unreachable code. The right argument expression does not complete normally",
		"cause": "This error message is generated when the evaluation of the right argument causes a stop of the execution sequence that avoid to call the operator for switch the argument is computed",
		"solution": "Remove the unreachable code",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unreachable_instance_of",
		"message": "Unreachable code: The if condition can never match. It is already handled by a previous condition",
		"cause": "Inside a condition of `if` statement, you have specified multiple tests with `instanceof`. Since all the boolean conditions are evaluated from left to right, an `instanceof` test never matches because a left-most `instanceof` already matches the same scope of types",
		"solution": "Remove the unmatchable `instanceof`",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.unused_local_variable",
		"message": "The value of the local variable *name* is not used",
		"cause": "You have declared a local variable with the given *name*, but never use it somewhere",
		"solution": "Remove the variable declaration; or Use the variable",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_disallowed",
		"message": "Invalid name '*name*'. You must not give to *feature* a name with reserved characters",
		"cause": "You have defined an name for the given *feature* that contains forbidden characters. The usual forbidden character is &#x24;. It is not allowed to use it inside a name because the SARL compiler uses it for internal implementation",
		"solution": "Rename your field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_disallowed",
		"message": "Invalid name '*name*'. You must not give to *feature* the same name as a reserved keyword",
		"cause": "You have defined an name for a *feature* that is equal to a reserved keyword",
		"solution": "Rename your field",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_disallowed",
		"message": "'*name*' is not a valid name",
		"cause": "This is the general error for notifying you that the name of an element is invalid. Most of the time, it is due to the use of a forbidden character into the *name*. The major forbidden character is &#x24;. It is not allowed to use it inside a name, even if it is allowed into the Java specification",
		"solution": "Rename the element",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_discouraged",
		"message": "'*name*' is a discouraged name",
		"cause": "This is the general message for notifying you that the name of an element is discouraged. Most of the time, it is due to the fact it may cause ambiguity with SARL language keywords, e.g. `self`",
		"solution": "Rename the element",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_discouraged",
		"message": "'self' is a discouraged name",
		"cause": "`self` is a name that is used in several other programming languages as a synonym of `this`. In order to avoid ambiguity, `self` is a discouraged name",
		"solution": "Rename the element",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_shadowing",
		"message": "The field '*field-name*' in '*type-name*' is hidding the inherited field '*super-field-name*'",
		"cause": "You have declared a field with the name *field-name* into the current type; but an accessible field with the same name is also declared into a super-type. It means that the value of the field into the super-type will not be accessible directly from the current type",
		"solution": "Rename field *field-name*",
		"level": "c/warning"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.variable_name_shadowing",
		"message": "Duplicate local variable *name*",
		"cause": "You have declared two different variables in the same scope but with exactly the same name. It is simply forbidden to hide local variables",
		"solution": "Rename one of the local variables",
		"level": "error"
	},
	{
		"code": "org.eclipse.xtext.xbase.validation.IssueCodes.wildcard_in_supertype",
		"message": "The type *type-name* cannot extend or implement *other-type*. A supertype may not specify any wildcard",
		"cause": "The super-type named *other-type* is defined with wildcard into its generic type parameters. It is forbidden to extends or implement a super-type with a wildcard",
		"level": "error"
	}
]

